/*
 * Akeyless API
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@akeyless.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.akeyless.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.akeyless.client.JSON;

/**
 * CreateSecret
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.10.0")
public class CreateSecret {
  public static final String SERIALIZED_NAME_ACCESSIBILITY = "accessibility";
  @SerializedName(SERIALIZED_NAME_ACCESSIBILITY)
  @javax.annotation.Nullable
  private String accessibility = "regular";

  public static final String SERIALIZED_NAME_CHANGE_EVENT = "change-event";
  @SerializedName(SERIALIZED_NAME_CHANGE_EVENT)
  @javax.annotation.Nullable
  private String changeEvent;

  public static final String SERIALIZED_NAME_CUSTOM_FIELD = "custom-field";
  @SerializedName(SERIALIZED_NAME_CUSTOM_FIELD)
  @javax.annotation.Nullable
  private Map<String, String> customField = new HashMap<>();

  public static final String SERIALIZED_NAME_DELETE_PROTECTION = "delete_protection";
  @SerializedName(SERIALIZED_NAME_DELETE_PROTECTION)
  @javax.annotation.Nullable
  private String deleteProtection;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nullable
  private String description;

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  @javax.annotation.Nullable
  private String format = "text";

  public static final String SERIALIZED_NAME_INJECT_URL = "inject-url";
  @SerializedName(SERIALIZED_NAME_INJECT_URL)
  @javax.annotation.Nullable
  private List<String> injectUrl = new ArrayList<>();

  public static final String SERIALIZED_NAME_JSON = "json";
  @SerializedName(SERIALIZED_NAME_JSON)
  @javax.annotation.Nullable
  private Boolean json = false;

  public static final String SERIALIZED_NAME_MAX_VERSIONS = "max-versions";
  @SerializedName(SERIALIZED_NAME_MAX_VERSIONS)
  @javax.annotation.Nullable
  private String maxVersions;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  @javax.annotation.Nullable
  private String metadata;

  public static final String SERIALIZED_NAME_MULTILINE_VALUE = "multiline_value";
  @SerializedName(SERIALIZED_NAME_MULTILINE_VALUE)
  @javax.annotation.Nullable
  private Boolean multilineValue;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_PASSWORD = "password";
  @SerializedName(SERIALIZED_NAME_PASSWORD)
  @javax.annotation.Nullable
  private String password;

  public static final String SERIALIZED_NAME_PROTECTION_KEY = "protection_key";
  @SerializedName(SERIALIZED_NAME_PROTECTION_KEY)
  @javax.annotation.Nullable
  private String protectionKey;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_BASTION_ISSUER = "secure-access-bastion-issuer";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_BASTION_ISSUER)
  @javax.annotation.Nullable
  private String secureAccessBastionIssuer;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_CERTIFICATE_ISSUER = "secure-access-certificate-issuer";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_CERTIFICATE_ISSUER)
  @javax.annotation.Nullable
  private String secureAccessCertificateIssuer;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_ENABLE = "secure-access-enable";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_ENABLE)
  @javax.annotation.Nullable
  private String secureAccessEnable;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_HOST = "secure-access-host";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_HOST)
  @javax.annotation.Nullable
  private List<String> secureAccessHost = new ArrayList<>();

  public static final String SERIALIZED_NAME_SECURE_ACCESS_RDP_USER = "secure-access-rdp-user";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_RDP_USER)
  @javax.annotation.Nullable
  private String secureAccessRdpUser;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_SSH_CREDS = "secure-access-ssh-creds";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_SSH_CREDS)
  @javax.annotation.Nullable
  private String secureAccessSshCreds;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_SSH_USER = "secure-access-ssh-user";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_SSH_USER)
  @javax.annotation.Nullable
  private String secureAccessSshUser;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_URL = "secure-access-url";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_URL)
  @javax.annotation.Nullable
  private String secureAccessUrl;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_WEB_BROWSING = "secure-access-web-browsing";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_WEB_BROWSING)
  @javax.annotation.Nullable
  private Boolean secureAccessWebBrowsing = false;

  public static final String SERIALIZED_NAME_SECURE_ACCESS_WEB_PROXY = "secure-access-web-proxy";
  @SerializedName(SERIALIZED_NAME_SECURE_ACCESS_WEB_PROXY)
  @javax.annotation.Nullable
  private Boolean secureAccessWebProxy = false;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private List<String> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  @javax.annotation.Nullable
  private String token;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nullable
  private String type = "generic";

  public static final String SERIALIZED_NAME_UID_TOKEN = "uid-token";
  @SerializedName(SERIALIZED_NAME_UID_TOKEN)
  @javax.annotation.Nullable
  private String uidToken;

  public static final String SERIALIZED_NAME_USERNAME = "username";
  @SerializedName(SERIALIZED_NAME_USERNAME)
  @javax.annotation.Nullable
  private String username;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  @javax.annotation.Nonnull
  private String value;

  public CreateSecret() {
  }

  public CreateSecret accessibility(@javax.annotation.Nullable String accessibility) {
    this.accessibility = accessibility;
    return this;
  }

  /**
   * for personal password manager
   * @return accessibility
   */
  @javax.annotation.Nullable
  public String getAccessibility() {
    return accessibility;
  }

  public void setAccessibility(@javax.annotation.Nullable String accessibility) {
    this.accessibility = accessibility;
  }


  public CreateSecret changeEvent(@javax.annotation.Nullable String changeEvent) {
    this.changeEvent = changeEvent;
    return this;
  }

  /**
   * Trigger an event when a secret value changed [true/false] (Relevant only for Static Secret)
   * @return changeEvent
   */
  @javax.annotation.Nullable
  public String getChangeEvent() {
    return changeEvent;
  }

  public void setChangeEvent(@javax.annotation.Nullable String changeEvent) {
    this.changeEvent = changeEvent;
  }


  public CreateSecret customField(@javax.annotation.Nullable Map<String, String> customField) {
    this.customField = customField;
    return this;
  }

  public CreateSecret putCustomFieldItem(String key, String customFieldItem) {
    if (this.customField == null) {
      this.customField = new HashMap<>();
    }
    this.customField.put(key, customFieldItem);
    return this;
  }

  /**
   * For Password Management use, additional fields
   * @return customField
   */
  @javax.annotation.Nullable
  public Map<String, String> getCustomField() {
    return customField;
  }

  public void setCustomField(@javax.annotation.Nullable Map<String, String> customField) {
    this.customField = customField;
  }


  public CreateSecret deleteProtection(@javax.annotation.Nullable String deleteProtection) {
    this.deleteProtection = deleteProtection;
    return this;
  }

  /**
   * Protection from accidental deletion of this object [true/false]
   * @return deleteProtection
   */
  @javax.annotation.Nullable
  public String getDeleteProtection() {
    return deleteProtection;
  }

  public void setDeleteProtection(@javax.annotation.Nullable String deleteProtection) {
    this.deleteProtection = deleteProtection;
  }


  public CreateSecret description(@javax.annotation.Nullable String description) {
    this.description = description;
    return this;
  }

  /**
   * Description of the object
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = description;
  }


  public CreateSecret format(@javax.annotation.Nullable String format) {
    this.format = format;
    return this;
  }

  /**
   * Secret format [text/json/key-value] (relevant only for type &#39;generic&#39;)
   * @return format
   */
  @javax.annotation.Nullable
  public String getFormat() {
    return format;
  }

  public void setFormat(@javax.annotation.Nullable String format) {
    this.format = format;
  }


  public CreateSecret injectUrl(@javax.annotation.Nullable List<String> injectUrl) {
    this.injectUrl = injectUrl;
    return this;
  }

  public CreateSecret addInjectUrlItem(String injectUrlItem) {
    if (this.injectUrl == null) {
      this.injectUrl = new ArrayList<>();
    }
    this.injectUrl.add(injectUrlItem);
    return this;
  }

  /**
   * For Password Management use, reflect the website context
   * @return injectUrl
   */
  @javax.annotation.Nullable
  public List<String> getInjectUrl() {
    return injectUrl;
  }

  public void setInjectUrl(@javax.annotation.Nullable List<String> injectUrl) {
    this.injectUrl = injectUrl;
  }


  public CreateSecret json(@javax.annotation.Nullable Boolean json) {
    this.json = json;
    return this;
  }

  /**
   * Set output format to JSON
   * @return json
   */
  @javax.annotation.Nullable
  public Boolean getJson() {
    return json;
  }

  public void setJson(@javax.annotation.Nullable Boolean json) {
    this.json = json;
  }


  public CreateSecret maxVersions(@javax.annotation.Nullable String maxVersions) {
    this.maxVersions = maxVersions;
    return this;
  }

  /**
   * Set the maximum number of versions, limited by the account settings defaults.
   * @return maxVersions
   */
  @javax.annotation.Nullable
  public String getMaxVersions() {
    return maxVersions;
  }

  public void setMaxVersions(@javax.annotation.Nullable String maxVersions) {
    this.maxVersions = maxVersions;
  }


  public CreateSecret metadata(@javax.annotation.Nullable String metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Deprecated - use description
   * @return metadata
   */
  @javax.annotation.Nullable
  public String getMetadata() {
    return metadata;
  }

  public void setMetadata(@javax.annotation.Nullable String metadata) {
    this.metadata = metadata;
  }


  public CreateSecret multilineValue(@javax.annotation.Nullable Boolean multilineValue) {
    this.multilineValue = multilineValue;
    return this;
  }

  /**
   * The provided value is a multiline value (separated by &#39;\\n&#39;)
   * @return multilineValue
   */
  @javax.annotation.Nullable
  public Boolean getMultilineValue() {
    return multilineValue;
  }

  public void setMultilineValue(@javax.annotation.Nullable Boolean multilineValue) {
    this.multilineValue = multilineValue;
  }


  public CreateSecret name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * Secret name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public CreateSecret password(@javax.annotation.Nullable String password) {
    this.password = password;
    return this;
  }

  /**
   * For Password Management use, additional fields
   * @return password
   */
  @javax.annotation.Nullable
  public String getPassword() {
    return password;
  }

  public void setPassword(@javax.annotation.Nullable String password) {
    this.password = password;
  }


  public CreateSecret protectionKey(@javax.annotation.Nullable String protectionKey) {
    this.protectionKey = protectionKey;
    return this;
  }

  /**
   * The name of a key that used to encrypt the secret value (if empty, the account default protectionKey key will be used)
   * @return protectionKey
   */
  @javax.annotation.Nullable
  public String getProtectionKey() {
    return protectionKey;
  }

  public void setProtectionKey(@javax.annotation.Nullable String protectionKey) {
    this.protectionKey = protectionKey;
  }


  public CreateSecret secureAccessBastionIssuer(@javax.annotation.Nullable String secureAccessBastionIssuer) {
    this.secureAccessBastionIssuer = secureAccessBastionIssuer;
    return this;
  }

  /**
   * Deprecated. use secure-access-certificate-issuer
   * @return secureAccessBastionIssuer
   */
  @javax.annotation.Nullable
  public String getSecureAccessBastionIssuer() {
    return secureAccessBastionIssuer;
  }

  public void setSecureAccessBastionIssuer(@javax.annotation.Nullable String secureAccessBastionIssuer) {
    this.secureAccessBastionIssuer = secureAccessBastionIssuer;
  }


  public CreateSecret secureAccessCertificateIssuer(@javax.annotation.Nullable String secureAccessCertificateIssuer) {
    this.secureAccessCertificateIssuer = secureAccessCertificateIssuer;
    return this;
  }

  /**
   * Path to the SSH Certificate Issuer for your Akeyless Secure Access
   * @return secureAccessCertificateIssuer
   */
  @javax.annotation.Nullable
  public String getSecureAccessCertificateIssuer() {
    return secureAccessCertificateIssuer;
  }

  public void setSecureAccessCertificateIssuer(@javax.annotation.Nullable String secureAccessCertificateIssuer) {
    this.secureAccessCertificateIssuer = secureAccessCertificateIssuer;
  }


  public CreateSecret secureAccessEnable(@javax.annotation.Nullable String secureAccessEnable) {
    this.secureAccessEnable = secureAccessEnable;
    return this;
  }

  /**
   * Enable/Disable secure remote access [true/false]
   * @return secureAccessEnable
   */
  @javax.annotation.Nullable
  public String getSecureAccessEnable() {
    return secureAccessEnable;
  }

  public void setSecureAccessEnable(@javax.annotation.Nullable String secureAccessEnable) {
    this.secureAccessEnable = secureAccessEnable;
  }


  public CreateSecret secureAccessHost(@javax.annotation.Nullable List<String> secureAccessHost) {
    this.secureAccessHost = secureAccessHost;
    return this;
  }

  public CreateSecret addSecureAccessHostItem(String secureAccessHostItem) {
    if (this.secureAccessHost == null) {
      this.secureAccessHost = new ArrayList<>();
    }
    this.secureAccessHost.add(secureAccessHostItem);
    return this;
  }

  /**
   * Target servers for connections (In case of Linked Target association, host(s) will inherit Linked Target hosts - Relevant only for Dynamic Secrets/producers)
   * @return secureAccessHost
   */
  @javax.annotation.Nullable
  public List<String> getSecureAccessHost() {
    return secureAccessHost;
  }

  public void setSecureAccessHost(@javax.annotation.Nullable List<String> secureAccessHost) {
    this.secureAccessHost = secureAccessHost;
  }


  public CreateSecret secureAccessRdpUser(@javax.annotation.Nullable String secureAccessRdpUser) {
    this.secureAccessRdpUser = secureAccessRdpUser;
    return this;
  }

  /**
   * Remote Desktop Username
   * @return secureAccessRdpUser
   */
  @javax.annotation.Nullable
  public String getSecureAccessRdpUser() {
    return secureAccessRdpUser;
  }

  public void setSecureAccessRdpUser(@javax.annotation.Nullable String secureAccessRdpUser) {
    this.secureAccessRdpUser = secureAccessRdpUser;
  }


  public CreateSecret secureAccessSshCreds(@javax.annotation.Nullable String secureAccessSshCreds) {
    this.secureAccessSshCreds = secureAccessSshCreds;
    return this;
  }

  /**
   * Static-Secret values contains SSH Credentials, either Private Key or Password [password/private-key]
   * @return secureAccessSshCreds
   */
  @javax.annotation.Nullable
  public String getSecureAccessSshCreds() {
    return secureAccessSshCreds;
  }

  public void setSecureAccessSshCreds(@javax.annotation.Nullable String secureAccessSshCreds) {
    this.secureAccessSshCreds = secureAccessSshCreds;
  }


  public CreateSecret secureAccessSshUser(@javax.annotation.Nullable String secureAccessSshUser) {
    this.secureAccessSshUser = secureAccessSshUser;
    return this;
  }

  /**
   * Override the SSH username as indicated in SSH Certificate Issuer
   * @return secureAccessSshUser
   */
  @javax.annotation.Nullable
  public String getSecureAccessSshUser() {
    return secureAccessSshUser;
  }

  public void setSecureAccessSshUser(@javax.annotation.Nullable String secureAccessSshUser) {
    this.secureAccessSshUser = secureAccessSshUser;
  }


  public CreateSecret secureAccessUrl(@javax.annotation.Nullable String secureAccessUrl) {
    this.secureAccessUrl = secureAccessUrl;
    return this;
  }

  /**
   * Destination URL to inject secrets
   * @return secureAccessUrl
   */
  @javax.annotation.Nullable
  public String getSecureAccessUrl() {
    return secureAccessUrl;
  }

  public void setSecureAccessUrl(@javax.annotation.Nullable String secureAccessUrl) {
    this.secureAccessUrl = secureAccessUrl;
  }


  public CreateSecret secureAccessWebBrowsing(@javax.annotation.Nullable Boolean secureAccessWebBrowsing) {
    this.secureAccessWebBrowsing = secureAccessWebBrowsing;
    return this;
  }

  /**
   * Secure browser via Akeyless&#39;s Secure Remote Access (SRA)
   * @return secureAccessWebBrowsing
   */
  @javax.annotation.Nullable
  public Boolean getSecureAccessWebBrowsing() {
    return secureAccessWebBrowsing;
  }

  public void setSecureAccessWebBrowsing(@javax.annotation.Nullable Boolean secureAccessWebBrowsing) {
    this.secureAccessWebBrowsing = secureAccessWebBrowsing;
  }


  public CreateSecret secureAccessWebProxy(@javax.annotation.Nullable Boolean secureAccessWebProxy) {
    this.secureAccessWebProxy = secureAccessWebProxy;
    return this;
  }

  /**
   * Web-Proxy via Akeyless&#39;s Secure Remote Access (SRA)
   * @return secureAccessWebProxy
   */
  @javax.annotation.Nullable
  public Boolean getSecureAccessWebProxy() {
    return secureAccessWebProxy;
  }

  public void setSecureAccessWebProxy(@javax.annotation.Nullable Boolean secureAccessWebProxy) {
    this.secureAccessWebProxy = secureAccessWebProxy;
  }


  public CreateSecret tags(@javax.annotation.Nullable List<String> tags) {
    this.tags = tags;
    return this;
  }

  public CreateSecret addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * Add tags attached to this object
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable List<String> tags) {
    this.tags = tags;
  }


  public CreateSecret token(@javax.annotation.Nullable String token) {
    this.token = token;
    return this;
  }

  /**
   * Authentication token (see &#x60;/auth&#x60; and &#x60;/configure&#x60;)
   * @return token
   */
  @javax.annotation.Nullable
  public String getToken() {
    return token;
  }

  public void setToken(@javax.annotation.Nullable String token) {
    this.token = token;
  }


  public CreateSecret type(@javax.annotation.Nullable String type) {
    this.type = type;
    return this;
  }

  /**
   * The secret sub type [generic/password]
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(@javax.annotation.Nullable String type) {
    this.type = type;
  }


  public CreateSecret uidToken(@javax.annotation.Nullable String uidToken) {
    this.uidToken = uidToken;
    return this;
  }

  /**
   * The universal identity token, Required only for universal_identity authentication
   * @return uidToken
   */
  @javax.annotation.Nullable
  public String getUidToken() {
    return uidToken;
  }

  public void setUidToken(@javax.annotation.Nullable String uidToken) {
    this.uidToken = uidToken;
  }


  public CreateSecret username(@javax.annotation.Nullable String username) {
    this.username = username;
    return this;
  }

  /**
   * For Password Management use
   * @return username
   */
  @javax.annotation.Nullable
  public String getUsername() {
    return username;
  }

  public void setUsername(@javax.annotation.Nullable String username) {
    this.username = username;
  }


  public CreateSecret value(@javax.annotation.Nonnull String value) {
    this.value = value;
    return this;
  }

  /**
   * The secret value (relevant only for type &#39;generic&#39;)
   * @return value
   */
  @javax.annotation.Nonnull
  public String getValue() {
    return value;
  }

  public void setValue(@javax.annotation.Nonnull String value) {
    this.value = value;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateSecret createSecret = (CreateSecret) o;
    return Objects.equals(this.accessibility, createSecret.accessibility) &&
        Objects.equals(this.changeEvent, createSecret.changeEvent) &&
        Objects.equals(this.customField, createSecret.customField) &&
        Objects.equals(this.deleteProtection, createSecret.deleteProtection) &&
        Objects.equals(this.description, createSecret.description) &&
        Objects.equals(this.format, createSecret.format) &&
        Objects.equals(this.injectUrl, createSecret.injectUrl) &&
        Objects.equals(this.json, createSecret.json) &&
        Objects.equals(this.maxVersions, createSecret.maxVersions) &&
        Objects.equals(this.metadata, createSecret.metadata) &&
        Objects.equals(this.multilineValue, createSecret.multilineValue) &&
        Objects.equals(this.name, createSecret.name) &&
        Objects.equals(this.password, createSecret.password) &&
        Objects.equals(this.protectionKey, createSecret.protectionKey) &&
        Objects.equals(this.secureAccessBastionIssuer, createSecret.secureAccessBastionIssuer) &&
        Objects.equals(this.secureAccessCertificateIssuer, createSecret.secureAccessCertificateIssuer) &&
        Objects.equals(this.secureAccessEnable, createSecret.secureAccessEnable) &&
        Objects.equals(this.secureAccessHost, createSecret.secureAccessHost) &&
        Objects.equals(this.secureAccessRdpUser, createSecret.secureAccessRdpUser) &&
        Objects.equals(this.secureAccessSshCreds, createSecret.secureAccessSshCreds) &&
        Objects.equals(this.secureAccessSshUser, createSecret.secureAccessSshUser) &&
        Objects.equals(this.secureAccessUrl, createSecret.secureAccessUrl) &&
        Objects.equals(this.secureAccessWebBrowsing, createSecret.secureAccessWebBrowsing) &&
        Objects.equals(this.secureAccessWebProxy, createSecret.secureAccessWebProxy) &&
        Objects.equals(this.tags, createSecret.tags) &&
        Objects.equals(this.token, createSecret.token) &&
        Objects.equals(this.type, createSecret.type) &&
        Objects.equals(this.uidToken, createSecret.uidToken) &&
        Objects.equals(this.username, createSecret.username) &&
        Objects.equals(this.value, createSecret.value);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessibility, changeEvent, customField, deleteProtection, description, format, injectUrl, json, maxVersions, metadata, multilineValue, name, password, protectionKey, secureAccessBastionIssuer, secureAccessCertificateIssuer, secureAccessEnable, secureAccessHost, secureAccessRdpUser, secureAccessSshCreds, secureAccessSshUser, secureAccessUrl, secureAccessWebBrowsing, secureAccessWebProxy, tags, token, type, uidToken, username, value);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateSecret {\n");
    sb.append("    accessibility: ").append(toIndentedString(accessibility)).append("\n");
    sb.append("    changeEvent: ").append(toIndentedString(changeEvent)).append("\n");
    sb.append("    customField: ").append(toIndentedString(customField)).append("\n");
    sb.append("    deleteProtection: ").append(toIndentedString(deleteProtection)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    injectUrl: ").append(toIndentedString(injectUrl)).append("\n");
    sb.append("    json: ").append(toIndentedString(json)).append("\n");
    sb.append("    maxVersions: ").append(toIndentedString(maxVersions)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    multilineValue: ").append(toIndentedString(multilineValue)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    protectionKey: ").append(toIndentedString(protectionKey)).append("\n");
    sb.append("    secureAccessBastionIssuer: ").append(toIndentedString(secureAccessBastionIssuer)).append("\n");
    sb.append("    secureAccessCertificateIssuer: ").append(toIndentedString(secureAccessCertificateIssuer)).append("\n");
    sb.append("    secureAccessEnable: ").append(toIndentedString(secureAccessEnable)).append("\n");
    sb.append("    secureAccessHost: ").append(toIndentedString(secureAccessHost)).append("\n");
    sb.append("    secureAccessRdpUser: ").append(toIndentedString(secureAccessRdpUser)).append("\n");
    sb.append("    secureAccessSshCreds: ").append(toIndentedString(secureAccessSshCreds)).append("\n");
    sb.append("    secureAccessSshUser: ").append(toIndentedString(secureAccessSshUser)).append("\n");
    sb.append("    secureAccessUrl: ").append(toIndentedString(secureAccessUrl)).append("\n");
    sb.append("    secureAccessWebBrowsing: ").append(toIndentedString(secureAccessWebBrowsing)).append("\n");
    sb.append("    secureAccessWebProxy: ").append(toIndentedString(secureAccessWebProxy)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    uidToken: ").append(toIndentedString(uidToken)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessibility");
    openapiFields.add("change-event");
    openapiFields.add("custom-field");
    openapiFields.add("delete_protection");
    openapiFields.add("description");
    openapiFields.add("format");
    openapiFields.add("inject-url");
    openapiFields.add("json");
    openapiFields.add("max-versions");
    openapiFields.add("metadata");
    openapiFields.add("multiline_value");
    openapiFields.add("name");
    openapiFields.add("password");
    openapiFields.add("protection_key");
    openapiFields.add("secure-access-bastion-issuer");
    openapiFields.add("secure-access-certificate-issuer");
    openapiFields.add("secure-access-enable");
    openapiFields.add("secure-access-host");
    openapiFields.add("secure-access-rdp-user");
    openapiFields.add("secure-access-ssh-creds");
    openapiFields.add("secure-access-ssh-user");
    openapiFields.add("secure-access-url");
    openapiFields.add("secure-access-web-browsing");
    openapiFields.add("secure-access-web-proxy");
    openapiFields.add("tags");
    openapiFields.add("token");
    openapiFields.add("type");
    openapiFields.add("uid-token");
    openapiFields.add("username");
    openapiFields.add("value");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("value");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateSecret
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateSecret.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateSecret is not found in the empty JSON string", CreateSecret.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateSecret.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateSecret` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateSecret.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accessibility") != null && !jsonObj.get("accessibility").isJsonNull()) && !jsonObj.get("accessibility").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accessibility` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accessibility").toString()));
      }
      if ((jsonObj.get("change-event") != null && !jsonObj.get("change-event").isJsonNull()) && !jsonObj.get("change-event").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `change-event` to be a primitive type in the JSON string but got `%s`", jsonObj.get("change-event").toString()));
      }
      if ((jsonObj.get("delete_protection") != null && !jsonObj.get("delete_protection").isJsonNull()) && !jsonObj.get("delete_protection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delete_protection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delete_protection").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("inject-url") != null && !jsonObj.get("inject-url").isJsonNull() && !jsonObj.get("inject-url").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `inject-url` to be an array in the JSON string but got `%s`", jsonObj.get("inject-url").toString()));
      }
      if ((jsonObj.get("max-versions") != null && !jsonObj.get("max-versions").isJsonNull()) && !jsonObj.get("max-versions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `max-versions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("max-versions").toString()));
      }
      if ((jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) && !jsonObj.get("metadata").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadata` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadata").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("password") != null && !jsonObj.get("password").isJsonNull()) && !jsonObj.get("password").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password").toString()));
      }
      if ((jsonObj.get("protection_key") != null && !jsonObj.get("protection_key").isJsonNull()) && !jsonObj.get("protection_key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protection_key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protection_key").toString()));
      }
      if ((jsonObj.get("secure-access-bastion-issuer") != null && !jsonObj.get("secure-access-bastion-issuer").isJsonNull()) && !jsonObj.get("secure-access-bastion-issuer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-bastion-issuer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-bastion-issuer").toString()));
      }
      if ((jsonObj.get("secure-access-certificate-issuer") != null && !jsonObj.get("secure-access-certificate-issuer").isJsonNull()) && !jsonObj.get("secure-access-certificate-issuer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-certificate-issuer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-certificate-issuer").toString()));
      }
      if ((jsonObj.get("secure-access-enable") != null && !jsonObj.get("secure-access-enable").isJsonNull()) && !jsonObj.get("secure-access-enable").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-enable` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-enable").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("secure-access-host") != null && !jsonObj.get("secure-access-host").isJsonNull() && !jsonObj.get("secure-access-host").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-host` to be an array in the JSON string but got `%s`", jsonObj.get("secure-access-host").toString()));
      }
      if ((jsonObj.get("secure-access-rdp-user") != null && !jsonObj.get("secure-access-rdp-user").isJsonNull()) && !jsonObj.get("secure-access-rdp-user").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-rdp-user` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-rdp-user").toString()));
      }
      if ((jsonObj.get("secure-access-ssh-creds") != null && !jsonObj.get("secure-access-ssh-creds").isJsonNull()) && !jsonObj.get("secure-access-ssh-creds").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-ssh-creds` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-ssh-creds").toString()));
      }
      if ((jsonObj.get("secure-access-ssh-user") != null && !jsonObj.get("secure-access-ssh-user").isJsonNull()) && !jsonObj.get("secure-access-ssh-user").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-ssh-user` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-ssh-user").toString()));
      }
      if ((jsonObj.get("secure-access-url") != null && !jsonObj.get("secure-access-url").isJsonNull()) && !jsonObj.get("secure-access-url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure-access-url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure-access-url").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
      if ((jsonObj.get("token") != null && !jsonObj.get("token").isJsonNull()) && !jsonObj.get("token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("uid-token") != null && !jsonObj.get("uid-token").isJsonNull()) && !jsonObj.get("uid-token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid-token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid-token").toString()));
      }
      if ((jsonObj.get("username") != null && !jsonObj.get("username").isJsonNull()) && !jsonObj.get("username").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `username` to be a primitive type in the JSON string but got `%s`", jsonObj.get("username").toString()));
      }
      if (!jsonObj.get("value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("value").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateSecret.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateSecret' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateSecret> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateSecret.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateSecret>() {
           @Override
           public void write(JsonWriter out, CreateSecret value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateSecret read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateSecret given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateSecret
   * @throws IOException if the JSON string is invalid with respect to CreateSecret
   */
  public static CreateSecret fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateSecret.class);
  }

  /**
   * Convert an instance of CreateSecret to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

