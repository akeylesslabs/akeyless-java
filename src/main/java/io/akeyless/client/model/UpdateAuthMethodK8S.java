/*
 * Akeyless API
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@akeyless.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.akeyless.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * updateAuthMethodK8S is a command that updates a new auth method that will be able to authenticate using K8S.
 */
@ApiModel(description = "updateAuthMethodK8S is a command that updates a new auth method that will be able to authenticate using K8S.")

public class UpdateAuthMethodK8S {
  public static final String SERIALIZED_NAME_ACCESS_EXPIRES = "access-expires";
  @SerializedName(SERIALIZED_NAME_ACCESS_EXPIRES)
  private Long accessExpires = 0l;

  public static final String SERIALIZED_NAME_AUDIENCE = "audience";
  @SerializedName(SERIALIZED_NAME_AUDIENCE)
  private String audience;

  public static final String SERIALIZED_NAME_BOUND_IPS = "bound-ips";
  @SerializedName(SERIALIZED_NAME_BOUND_IPS)
  private List<String> boundIps = null;

  public static final String SERIALIZED_NAME_BOUND_NAMESPACES = "bound-namespaces";
  @SerializedName(SERIALIZED_NAME_BOUND_NAMESPACES)
  private List<String> boundNamespaces = null;

  public static final String SERIALIZED_NAME_BOUND_POD_NAMES = "bound-pod-names";
  @SerializedName(SERIALIZED_NAME_BOUND_POD_NAMES)
  private List<String> boundPodNames = null;

  public static final String SERIALIZED_NAME_BOUND_SA_NAMES = "bound-sa-names";
  @SerializedName(SERIALIZED_NAME_BOUND_SA_NAMES)
  private List<String> boundSaNames = null;

  public static final String SERIALIZED_NAME_FORCE_SUB_CLAIMS = "force-sub-claims";
  @SerializedName(SERIALIZED_NAME_FORCE_SUB_CLAIMS)
  private Boolean forceSubClaims;

  public static final String SERIALIZED_NAME_GEN_KEY = "gen-key";
  @SerializedName(SERIALIZED_NAME_GEN_KEY)
  private String genKey = "true";

  public static final String SERIALIZED_NAME_JWT_TTL = "jwt-ttl";
  @SerializedName(SERIALIZED_NAME_JWT_TTL)
  private Long jwtTtl;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NEW_NAME = "new-name";
  @SerializedName(SERIALIZED_NAME_NEW_NAME)
  private String newName;

  public static final String SERIALIZED_NAME_PUBLIC_KEY = "public-key";
  @SerializedName(SERIALIZED_NAME_PUBLIC_KEY)
  private String publicKey;

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  private String token;

  public static final String SERIALIZED_NAME_UID_TOKEN = "uid-token";
  @SerializedName(SERIALIZED_NAME_UID_TOKEN)
  private String uidToken;


  public UpdateAuthMethodK8S accessExpires(Long accessExpires) {
    
    this.accessExpires = accessExpires;
    return this;
  }

   /**
   * Access expiration date in Unix timestamp (select 0 for access without expiry date)
   * @return accessExpires
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Access expiration date in Unix timestamp (select 0 for access without expiry date)")

  public Long getAccessExpires() {
    return accessExpires;
  }


  public void setAccessExpires(Long accessExpires) {
    this.accessExpires = accessExpires;
  }


  public UpdateAuthMethodK8S audience(String audience) {
    
    this.audience = audience;
    return this;
  }

   /**
   * The audience in the Kubernetes JWT that the access is restricted to
   * @return audience
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The audience in the Kubernetes JWT that the access is restricted to")

  public String getAudience() {
    return audience;
  }


  public void setAudience(String audience) {
    this.audience = audience;
  }


  public UpdateAuthMethodK8S boundIps(List<String> boundIps) {
    
    this.boundIps = boundIps;
    return this;
  }

  public UpdateAuthMethodK8S addBoundIpsItem(String boundIpsItem) {
    if (this.boundIps == null) {
      this.boundIps = new ArrayList<String>();
    }
    this.boundIps.add(boundIpsItem);
    return this;
  }

   /**
   * A CIDR whitelist with the IPs that the access is restricted to
   * @return boundIps
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A CIDR whitelist with the IPs that the access is restricted to")

  public List<String> getBoundIps() {
    return boundIps;
  }


  public void setBoundIps(List<String> boundIps) {
    this.boundIps = boundIps;
  }


  public UpdateAuthMethodK8S boundNamespaces(List<String> boundNamespaces) {
    
    this.boundNamespaces = boundNamespaces;
    return this;
  }

  public UpdateAuthMethodK8S addBoundNamespacesItem(String boundNamespacesItem) {
    if (this.boundNamespaces == null) {
      this.boundNamespaces = new ArrayList<String>();
    }
    this.boundNamespaces.add(boundNamespacesItem);
    return this;
  }

   /**
   * A list of namespaces that the access is restricted to
   * @return boundNamespaces
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of namespaces that the access is restricted to")

  public List<String> getBoundNamespaces() {
    return boundNamespaces;
  }


  public void setBoundNamespaces(List<String> boundNamespaces) {
    this.boundNamespaces = boundNamespaces;
  }


  public UpdateAuthMethodK8S boundPodNames(List<String> boundPodNames) {
    
    this.boundPodNames = boundPodNames;
    return this;
  }

  public UpdateAuthMethodK8S addBoundPodNamesItem(String boundPodNamesItem) {
    if (this.boundPodNames == null) {
      this.boundPodNames = new ArrayList<String>();
    }
    this.boundPodNames.add(boundPodNamesItem);
    return this;
  }

   /**
   * A list of pod names that the access is restricted to
   * @return boundPodNames
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of pod names that the access is restricted to")

  public List<String> getBoundPodNames() {
    return boundPodNames;
  }


  public void setBoundPodNames(List<String> boundPodNames) {
    this.boundPodNames = boundPodNames;
  }


  public UpdateAuthMethodK8S boundSaNames(List<String> boundSaNames) {
    
    this.boundSaNames = boundSaNames;
    return this;
  }

  public UpdateAuthMethodK8S addBoundSaNamesItem(String boundSaNamesItem) {
    if (this.boundSaNames == null) {
      this.boundSaNames = new ArrayList<String>();
    }
    this.boundSaNames.add(boundSaNamesItem);
    return this;
  }

   /**
   * A list of service account names that the access is restricted to
   * @return boundSaNames
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of service account names that the access is restricted to")

  public List<String> getBoundSaNames() {
    return boundSaNames;
  }


  public void setBoundSaNames(List<String> boundSaNames) {
    this.boundSaNames = boundSaNames;
  }


  public UpdateAuthMethodK8S forceSubClaims(Boolean forceSubClaims) {
    
    this.forceSubClaims = forceSubClaims;
    return this;
  }

   /**
   * if true: enforce role-association must include sub claims
   * @return forceSubClaims
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "if true: enforce role-association must include sub claims")

  public Boolean getForceSubClaims() {
    return forceSubClaims;
  }


  public void setForceSubClaims(Boolean forceSubClaims) {
    this.forceSubClaims = forceSubClaims;
  }


  public UpdateAuthMethodK8S genKey(String genKey) {
    
    this.genKey = genKey;
    return this;
  }

   /**
   * If this flag is set to true, there is no need to manually provide a public key for the Kubernetes Auth Method, and instead, a key pair, will be generated as part of the command and the private part of the key will be returned (the private key is required for the K8S Auth Config in the Akeyless Gateway)
   * @return genKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If this flag is set to true, there is no need to manually provide a public key for the Kubernetes Auth Method, and instead, a key pair, will be generated as part of the command and the private part of the key will be returned (the private key is required for the K8S Auth Config in the Akeyless Gateway)")

  public String getGenKey() {
    return genKey;
  }


  public void setGenKey(String genKey) {
    this.genKey = genKey;
  }


  public UpdateAuthMethodK8S jwtTtl(Long jwtTtl) {
    
    this.jwtTtl = jwtTtl;
    return this;
  }

   /**
   * Jwt TTL
   * @return jwtTtl
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Jwt TTL")

  public Long getJwtTtl() {
    return jwtTtl;
  }


  public void setJwtTtl(Long jwtTtl) {
    this.jwtTtl = jwtTtl;
  }


  public UpdateAuthMethodK8S name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Auth Method name
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Auth Method name")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public UpdateAuthMethodK8S newName(String newName) {
    
    this.newName = newName;
    return this;
  }

   /**
   * Auth Method new name
   * @return newName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Auth Method new name")

  public String getNewName() {
    return newName;
  }


  public void setNewName(String newName) {
    this.newName = newName;
  }


  public UpdateAuthMethodK8S publicKey(String publicKey) {
    
    this.publicKey = publicKey;
    return this;
  }

   /**
   * Base64-encoded public key text for K8S authentication method is required [RSA2048]
   * @return publicKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Base64-encoded public key text for K8S authentication method is required [RSA2048]")

  public String getPublicKey() {
    return publicKey;
  }


  public void setPublicKey(String publicKey) {
    this.publicKey = publicKey;
  }


  public UpdateAuthMethodK8S token(String token) {
    
    this.token = token;
    return this;
  }

   /**
   * Authentication token (see &#x60;/auth&#x60; and &#x60;/configure&#x60;)
   * @return token
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Authentication token (see `/auth` and `/configure`)")

  public String getToken() {
    return token;
  }


  public void setToken(String token) {
    this.token = token;
  }


  public UpdateAuthMethodK8S uidToken(String uidToken) {
    
    this.uidToken = uidToken;
    return this;
  }

   /**
   * The universal identity token, Required only for universal_identity authentication
   * @return uidToken
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The universal identity token, Required only for universal_identity authentication")

  public String getUidToken() {
    return uidToken;
  }


  public void setUidToken(String uidToken) {
    this.uidToken = uidToken;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateAuthMethodK8S updateAuthMethodK8S = (UpdateAuthMethodK8S) o;
    return Objects.equals(this.accessExpires, updateAuthMethodK8S.accessExpires) &&
        Objects.equals(this.audience, updateAuthMethodK8S.audience) &&
        Objects.equals(this.boundIps, updateAuthMethodK8S.boundIps) &&
        Objects.equals(this.boundNamespaces, updateAuthMethodK8S.boundNamespaces) &&
        Objects.equals(this.boundPodNames, updateAuthMethodK8S.boundPodNames) &&
        Objects.equals(this.boundSaNames, updateAuthMethodK8S.boundSaNames) &&
        Objects.equals(this.forceSubClaims, updateAuthMethodK8S.forceSubClaims) &&
        Objects.equals(this.genKey, updateAuthMethodK8S.genKey) &&
        Objects.equals(this.jwtTtl, updateAuthMethodK8S.jwtTtl) &&
        Objects.equals(this.name, updateAuthMethodK8S.name) &&
        Objects.equals(this.newName, updateAuthMethodK8S.newName) &&
        Objects.equals(this.publicKey, updateAuthMethodK8S.publicKey) &&
        Objects.equals(this.token, updateAuthMethodK8S.token) &&
        Objects.equals(this.uidToken, updateAuthMethodK8S.uidToken);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessExpires, audience, boundIps, boundNamespaces, boundPodNames, boundSaNames, forceSubClaims, genKey, jwtTtl, name, newName, publicKey, token, uidToken);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateAuthMethodK8S {\n");
    sb.append("    accessExpires: ").append(toIndentedString(accessExpires)).append("\n");
    sb.append("    audience: ").append(toIndentedString(audience)).append("\n");
    sb.append("    boundIps: ").append(toIndentedString(boundIps)).append("\n");
    sb.append("    boundNamespaces: ").append(toIndentedString(boundNamespaces)).append("\n");
    sb.append("    boundPodNames: ").append(toIndentedString(boundPodNames)).append("\n");
    sb.append("    boundSaNames: ").append(toIndentedString(boundSaNames)).append("\n");
    sb.append("    forceSubClaims: ").append(toIndentedString(forceSubClaims)).append("\n");
    sb.append("    genKey: ").append(toIndentedString(genKey)).append("\n");
    sb.append("    jwtTtl: ").append(toIndentedString(jwtTtl)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    newName: ").append(toIndentedString(newName)).append("\n");
    sb.append("    publicKey: ").append(toIndentedString(publicKey)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    uidToken: ").append(toIndentedString(uidToken)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

