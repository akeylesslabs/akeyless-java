/*
 * Akeyless API
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@akeyless.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.akeyless.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * RegexpTokenizerInfo represents a general Regexp tokenization template
 */
@ApiModel(description = "RegexpTokenizerInfo represents a general Regexp tokenization template")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class RegexpTokenizerInfo {
  public static final String SERIALIZED_NAME_ALPHABET = "alphabet";
  @SerializedName(SERIALIZED_NAME_ALPHABET)
  private String alphabet;

  public static final String SERIALIZED_NAME_DECODING_TEMPLATE = "decoding_template";
  @SerializedName(SERIALIZED_NAME_DECODING_TEMPLATE)
  private String decodingTemplate;

  public static final String SERIALIZED_NAME_ENCODING_TEMPLATE = "encoding_template";
  @SerializedName(SERIALIZED_NAME_ENCODING_TEMPLATE)
  private String encodingTemplate;

  public static final String SERIALIZED_NAME_PATTERN = "pattern";
  @SerializedName(SERIALIZED_NAME_PATTERN)
  private String pattern;

  public RegexpTokenizerInfo() { 
  }

  public RegexpTokenizerInfo alphabet(String alphabet) {
    
    this.alphabet = alphabet;
    return this;
  }

   /**
   * The Alphabet used for the tokenization
   * @return alphabet
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The Alphabet used for the tokenization")

  public String getAlphabet() {
    return alphabet;
  }


  public void setAlphabet(String alphabet) {
    this.alphabet = alphabet;
  }


  public RegexpTokenizerInfo decodingTemplate(String decodingTemplate) {
    
    this.decodingTemplate = decodingTemplate;
    return this;
  }

   /**
   * Transformation to perform on the decrypted data
   * @return decodingTemplate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Transformation to perform on the decrypted data")

  public String getDecodingTemplate() {
    return decodingTemplate;
  }


  public void setDecodingTemplate(String decodingTemplate) {
    this.decodingTemplate = decodingTemplate;
  }


  public RegexpTokenizerInfo encodingTemplate(String encodingTemplate) {
    
    this.encodingTemplate = encodingTemplate;
    return this;
  }

   /**
   * Transformation to perform on the encrypted data, if the required output template doesn&#39;t match the input string The output Should still be valid for the Pattern, otherwise the secret would be able to be decrypted.
   * @return encodingTemplate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Transformation to perform on the encrypted data, if the required output template doesn't match the input string The output Should still be valid for the Pattern, otherwise the secret would be able to be decrypted.")

  public String getEncodingTemplate() {
    return encodingTemplate;
  }


  public void setEncodingTemplate(String encodingTemplate) {
    this.encodingTemplate = encodingTemplate;
  }


  public RegexpTokenizerInfo pattern(String pattern) {
    
    this.pattern = pattern;
    return this;
  }

   /**
   * Regexp pattern to extract and deposit the text/encdata
   * @return pattern
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Regexp pattern to extract and deposit the text/encdata")

  public String getPattern() {
    return pattern;
  }


  public void setPattern(String pattern) {
    this.pattern = pattern;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RegexpTokenizerInfo regexpTokenizerInfo = (RegexpTokenizerInfo) o;
    return Objects.equals(this.alphabet, regexpTokenizerInfo.alphabet) &&
        Objects.equals(this.decodingTemplate, regexpTokenizerInfo.decodingTemplate) &&
        Objects.equals(this.encodingTemplate, regexpTokenizerInfo.encodingTemplate) &&
        Objects.equals(this.pattern, regexpTokenizerInfo.pattern);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alphabet, decodingTemplate, encodingTemplate, pattern);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RegexpTokenizerInfo {\n");
    sb.append("    alphabet: ").append(toIndentedString(alphabet)).append("\n");
    sb.append("    decodingTemplate: ").append(toIndentedString(decodingTemplate)).append("\n");
    sb.append("    encodingTemplate: ").append(toIndentedString(encodingTemplate)).append("\n");
    sb.append("    pattern: ").append(toIndentedString(pattern)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

