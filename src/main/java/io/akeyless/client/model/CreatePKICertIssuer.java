/*
 * Akeyless API
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@akeyless.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.akeyless.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.akeyless.client.JSON;

/**
 * CreatePKICertIssuer
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.10.0")
public class CreatePKICertIssuer {
  public static final String SERIALIZED_NAME_ALLOW_ANY_NAME = "allow-any-name";
  @SerializedName(SERIALIZED_NAME_ALLOW_ANY_NAME)
  @javax.annotation.Nullable
  private Boolean allowAnyName;

  public static final String SERIALIZED_NAME_ALLOW_COPY_EXT_FROM_CSR = "allow-copy-ext-from-csr";
  @SerializedName(SERIALIZED_NAME_ALLOW_COPY_EXT_FROM_CSR)
  @javax.annotation.Nullable
  private Boolean allowCopyExtFromCsr;

  public static final String SERIALIZED_NAME_ALLOW_SUBDOMAINS = "allow-subdomains";
  @SerializedName(SERIALIZED_NAME_ALLOW_SUBDOMAINS)
  @javax.annotation.Nullable
  private Boolean allowSubdomains;

  public static final String SERIALIZED_NAME_ALLOWED_DOMAINS = "allowed-domains";
  @SerializedName(SERIALIZED_NAME_ALLOWED_DOMAINS)
  @javax.annotation.Nullable
  private String allowedDomains;

  public static final String SERIALIZED_NAME_ALLOWED_EXTRA_EXTENSIONS = "allowed-extra-extensions";
  @SerializedName(SERIALIZED_NAME_ALLOWED_EXTRA_EXTENSIONS)
  @javax.annotation.Nullable
  private String allowedExtraExtensions;

  public static final String SERIALIZED_NAME_ALLOWED_IP_SANS = "allowed-ip-sans";
  @SerializedName(SERIALIZED_NAME_ALLOWED_IP_SANS)
  @javax.annotation.Nullable
  private String allowedIpSans;

  public static final String SERIALIZED_NAME_ALLOWED_URI_SANS = "allowed-uri-sans";
  @SerializedName(SERIALIZED_NAME_ALLOWED_URI_SANS)
  @javax.annotation.Nullable
  private String allowedUriSans;

  public static final String SERIALIZED_NAME_AUTO_RENEW = "auto-renew";
  @SerializedName(SERIALIZED_NAME_AUTO_RENEW)
  @javax.annotation.Nullable
  private Boolean autoRenew;

  public static final String SERIALIZED_NAME_CA_TARGET = "ca-target";
  @SerializedName(SERIALIZED_NAME_CA_TARGET)
  @javax.annotation.Nullable
  private String caTarget;

  public static final String SERIALIZED_NAME_CLIENT_FLAG = "client-flag";
  @SerializedName(SERIALIZED_NAME_CLIENT_FLAG)
  @javax.annotation.Nullable
  private Boolean clientFlag;

  public static final String SERIALIZED_NAME_CODE_SIGNING_FLAG = "code-signing-flag";
  @SerializedName(SERIALIZED_NAME_CODE_SIGNING_FLAG)
  @javax.annotation.Nullable
  private Boolean codeSigningFlag;

  public static final String SERIALIZED_NAME_COUNTRY = "country";
  @SerializedName(SERIALIZED_NAME_COUNTRY)
  @javax.annotation.Nullable
  private String country;

  public static final String SERIALIZED_NAME_CREATE_PRIVATE_CRL = "create-private-crl";
  @SerializedName(SERIALIZED_NAME_CREATE_PRIVATE_CRL)
  @javax.annotation.Nullable
  private Boolean createPrivateCrl;

  public static final String SERIALIZED_NAME_CREATE_PUBLIC_CRL = "create-public-crl";
  @SerializedName(SERIALIZED_NAME_CREATE_PUBLIC_CRL)
  @javax.annotation.Nullable
  private Boolean createPublicCrl;

  public static final String SERIALIZED_NAME_CRITICAL_KEY_USAGE = "critical-key-usage";
  @SerializedName(SERIALIZED_NAME_CRITICAL_KEY_USAGE)
  @javax.annotation.Nullable
  private String criticalKeyUsage = "true";

  public static final String SERIALIZED_NAME_DELETE_PROTECTION = "delete_protection";
  @SerializedName(SERIALIZED_NAME_DELETE_PROTECTION)
  @javax.annotation.Nullable
  private String deleteProtection;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nullable
  private String description;

  public static final String SERIALIZED_NAME_DESTINATION_PATH = "destination-path";
  @SerializedName(SERIALIZED_NAME_DESTINATION_PATH)
  @javax.annotation.Nullable
  private String destinationPath;

  public static final String SERIALIZED_NAME_DISABLE_WILDCARDS = "disable-wildcards";
  @SerializedName(SERIALIZED_NAME_DISABLE_WILDCARDS)
  @javax.annotation.Nullable
  private Boolean disableWildcards;

  public static final String SERIALIZED_NAME_ENABLE_ACME = "enable-acme";
  @SerializedName(SERIALIZED_NAME_ENABLE_ACME)
  @javax.annotation.Nullable
  private Boolean enableAcme;

  public static final String SERIALIZED_NAME_EXPIRATION_EVENT_IN = "expiration-event-in";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_EVENT_IN)
  @javax.annotation.Nullable
  private List<String> expirationEventIn = new ArrayList<>();

  public static final String SERIALIZED_NAME_GW_CLUSTER_URL = "gw-cluster-url";
  @SerializedName(SERIALIZED_NAME_GW_CLUSTER_URL)
  @javax.annotation.Nullable
  private String gwClusterUrl;

  public static final String SERIALIZED_NAME_IS_CA = "is-ca";
  @SerializedName(SERIALIZED_NAME_IS_CA)
  @javax.annotation.Nullable
  private Boolean isCa;

  public static final String SERIALIZED_NAME_JSON = "json";
  @SerializedName(SERIALIZED_NAME_JSON)
  @javax.annotation.Nullable
  private Boolean json = false;

  public static final String SERIALIZED_NAME_KEY_USAGE = "key-usage";
  @SerializedName(SERIALIZED_NAME_KEY_USAGE)
  @javax.annotation.Nullable
  private String keyUsage = "DigitalSignature,KeyAgreement,KeyEncipherment";

  public static final String SERIALIZED_NAME_LOCALITY = "locality";
  @SerializedName(SERIALIZED_NAME_LOCALITY)
  @javax.annotation.Nullable
  private String locality;

  public static final String SERIALIZED_NAME_MAX_PATH_LEN = "max-path-len";
  @SerializedName(SERIALIZED_NAME_MAX_PATH_LEN)
  @javax.annotation.Nullable
  private Long maxPathLen = -1l;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  @javax.annotation.Nullable
  private String metadata;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_NOT_ENFORCE_HOSTNAMES = "not-enforce-hostnames";
  @SerializedName(SERIALIZED_NAME_NOT_ENFORCE_HOSTNAMES)
  @javax.annotation.Nullable
  private Boolean notEnforceHostnames;

  public static final String SERIALIZED_NAME_NOT_REQUIRE_CN = "not-require-cn";
  @SerializedName(SERIALIZED_NAME_NOT_REQUIRE_CN)
  @javax.annotation.Nullable
  private Boolean notRequireCn;

  public static final String SERIALIZED_NAME_ORGANIZATIONAL_UNITS = "organizational-units";
  @SerializedName(SERIALIZED_NAME_ORGANIZATIONAL_UNITS)
  @javax.annotation.Nullable
  private String organizationalUnits;

  public static final String SERIALIZED_NAME_ORGANIZATIONS = "organizations";
  @SerializedName(SERIALIZED_NAME_ORGANIZATIONS)
  @javax.annotation.Nullable
  private String organizations;

  public static final String SERIALIZED_NAME_POSTAL_CODE = "postal-code";
  @SerializedName(SERIALIZED_NAME_POSTAL_CODE)
  @javax.annotation.Nullable
  private String postalCode;

  public static final String SERIALIZED_NAME_PROTECT_CERTIFICATES = "protect-certificates";
  @SerializedName(SERIALIZED_NAME_PROTECT_CERTIFICATES)
  @javax.annotation.Nullable
  private Boolean protectCertificates;

  public static final String SERIALIZED_NAME_PROVINCE = "province";
  @SerializedName(SERIALIZED_NAME_PROVINCE)
  @javax.annotation.Nullable
  private String province;

  public static final String SERIALIZED_NAME_SCHEDULED_RENEW = "scheduled-renew";
  @SerializedName(SERIALIZED_NAME_SCHEDULED_RENEW)
  @javax.annotation.Nullable
  private Long scheduledRenew;

  public static final String SERIALIZED_NAME_SERVER_FLAG = "server-flag";
  @SerializedName(SERIALIZED_NAME_SERVER_FLAG)
  @javax.annotation.Nullable
  private Boolean serverFlag;

  public static final String SERIALIZED_NAME_SIGNER_KEY_NAME = "signer-key-name";
  @SerializedName(SERIALIZED_NAME_SIGNER_KEY_NAME)
  @javax.annotation.Nullable
  private String signerKeyName;

  public static final String SERIALIZED_NAME_STREET_ADDRESS = "street-address";
  @SerializedName(SERIALIZED_NAME_STREET_ADDRESS)
  @javax.annotation.Nullable
  private String streetAddress;

  public static final String SERIALIZED_NAME_TAG = "tag";
  @SerializedName(SERIALIZED_NAME_TAG)
  @javax.annotation.Nullable
  private List<String> tag = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  @javax.annotation.Nullable
  private String token;

  public static final String SERIALIZED_NAME_TTL = "ttl";
  @SerializedName(SERIALIZED_NAME_TTL)
  @javax.annotation.Nonnull
  private String ttl;

  public static final String SERIALIZED_NAME_UID_TOKEN = "uid-token";
  @SerializedName(SERIALIZED_NAME_UID_TOKEN)
  @javax.annotation.Nullable
  private String uidToken;

  public CreatePKICertIssuer() {
  }

  public CreatePKICertIssuer allowAnyName(@javax.annotation.Nullable Boolean allowAnyName) {
    this.allowAnyName = allowAnyName;
    return this;
  }

  /**
   * If set, clients can request certificates for any CN
   * @return allowAnyName
   */
  @javax.annotation.Nullable
  public Boolean getAllowAnyName() {
    return allowAnyName;
  }

  public void setAllowAnyName(@javax.annotation.Nullable Boolean allowAnyName) {
    this.allowAnyName = allowAnyName;
  }


  public CreatePKICertIssuer allowCopyExtFromCsr(@javax.annotation.Nullable Boolean allowCopyExtFromCsr) {
    this.allowCopyExtFromCsr = allowCopyExtFromCsr;
    return this;
  }

  /**
   * If set, will allow copying the extra extensions from the csr file (if given)
   * @return allowCopyExtFromCsr
   */
  @javax.annotation.Nullable
  public Boolean getAllowCopyExtFromCsr() {
    return allowCopyExtFromCsr;
  }

  public void setAllowCopyExtFromCsr(@javax.annotation.Nullable Boolean allowCopyExtFromCsr) {
    this.allowCopyExtFromCsr = allowCopyExtFromCsr;
  }


  public CreatePKICertIssuer allowSubdomains(@javax.annotation.Nullable Boolean allowSubdomains) {
    this.allowSubdomains = allowSubdomains;
    return this;
  }

  /**
   * If set, clients can request certificates for subdomains of the allowed domains
   * @return allowSubdomains
   */
  @javax.annotation.Nullable
  public Boolean getAllowSubdomains() {
    return allowSubdomains;
  }

  public void setAllowSubdomains(@javax.annotation.Nullable Boolean allowSubdomains) {
    this.allowSubdomains = allowSubdomains;
  }


  public CreatePKICertIssuer allowedDomains(@javax.annotation.Nullable String allowedDomains) {
    this.allowedDomains = allowedDomains;
    return this;
  }

  /**
   * A list of the allowed domains that clients can request to be included in the certificate (in a comma-delimited list)
   * @return allowedDomains
   */
  @javax.annotation.Nullable
  public String getAllowedDomains() {
    return allowedDomains;
  }

  public void setAllowedDomains(@javax.annotation.Nullable String allowedDomains) {
    this.allowedDomains = allowedDomains;
  }


  public CreatePKICertIssuer allowedExtraExtensions(@javax.annotation.Nullable String allowedExtraExtensions) {
    this.allowedExtraExtensions = allowedExtraExtensions;
    return this;
  }

  /**
   * A json string containing the allowed extra extensions for the pki cert issuer
   * @return allowedExtraExtensions
   */
  @javax.annotation.Nullable
  public String getAllowedExtraExtensions() {
    return allowedExtraExtensions;
  }

  public void setAllowedExtraExtensions(@javax.annotation.Nullable String allowedExtraExtensions) {
    this.allowedExtraExtensions = allowedExtraExtensions;
  }


  public CreatePKICertIssuer allowedIpSans(@javax.annotation.Nullable String allowedIpSans) {
    this.allowedIpSans = allowedIpSans;
    return this;
  }

  /**
   * A list of the allowed CIDRs for ips that clients can request to be included in the certificate as part of the IP Subject Alternative Names (in a comma-delimited list)
   * @return allowedIpSans
   */
  @javax.annotation.Nullable
  public String getAllowedIpSans() {
    return allowedIpSans;
  }

  public void setAllowedIpSans(@javax.annotation.Nullable String allowedIpSans) {
    this.allowedIpSans = allowedIpSans;
  }


  public CreatePKICertIssuer allowedUriSans(@javax.annotation.Nullable String allowedUriSans) {
    this.allowedUriSans = allowedUriSans;
    return this;
  }

  /**
   * A list of the allowed URIs that clients can request to be included in the certificate as part of the URI Subject Alternative Names (in a comma-delimited list)
   * @return allowedUriSans
   */
  @javax.annotation.Nullable
  public String getAllowedUriSans() {
    return allowedUriSans;
  }

  public void setAllowedUriSans(@javax.annotation.Nullable String allowedUriSans) {
    this.allowedUriSans = allowedUriSans;
  }


  public CreatePKICertIssuer autoRenew(@javax.annotation.Nullable Boolean autoRenew) {
    this.autoRenew = autoRenew;
    return this;
  }

  /**
   * Automatically renew certificates before expiration
   * @return autoRenew
   */
  @javax.annotation.Nullable
  public Boolean getAutoRenew() {
    return autoRenew;
  }

  public void setAutoRenew(@javax.annotation.Nullable Boolean autoRenew) {
    this.autoRenew = autoRenew;
  }


  public CreatePKICertIssuer caTarget(@javax.annotation.Nullable String caTarget) {
    this.caTarget = caTarget;
    return this;
  }

  /**
   * The name of an existing CA target to attach this PKI Certificate Issuer to, required in Public CA mode
   * @return caTarget
   */
  @javax.annotation.Nullable
  public String getCaTarget() {
    return caTarget;
  }

  public void setCaTarget(@javax.annotation.Nullable String caTarget) {
    this.caTarget = caTarget;
  }


  public CreatePKICertIssuer clientFlag(@javax.annotation.Nullable Boolean clientFlag) {
    this.clientFlag = clientFlag;
    return this;
  }

  /**
   * If set, certificates will be flagged for client auth use
   * @return clientFlag
   */
  @javax.annotation.Nullable
  public Boolean getClientFlag() {
    return clientFlag;
  }

  public void setClientFlag(@javax.annotation.Nullable Boolean clientFlag) {
    this.clientFlag = clientFlag;
  }


  public CreatePKICertIssuer codeSigningFlag(@javax.annotation.Nullable Boolean codeSigningFlag) {
    this.codeSigningFlag = codeSigningFlag;
    return this;
  }

  /**
   * If set, certificates will be flagged for code signing use
   * @return codeSigningFlag
   */
  @javax.annotation.Nullable
  public Boolean getCodeSigningFlag() {
    return codeSigningFlag;
  }

  public void setCodeSigningFlag(@javax.annotation.Nullable Boolean codeSigningFlag) {
    this.codeSigningFlag = codeSigningFlag;
  }


  public CreatePKICertIssuer country(@javax.annotation.Nullable String country) {
    this.country = country;
    return this;
  }

  /**
   * A comma-separated list of countries that will be set in the issued certificate
   * @return country
   */
  @javax.annotation.Nullable
  public String getCountry() {
    return country;
  }

  public void setCountry(@javax.annotation.Nullable String country) {
    this.country = country;
  }


  public CreatePKICertIssuer createPrivateCrl(@javax.annotation.Nullable Boolean createPrivateCrl) {
    this.createPrivateCrl = createPrivateCrl;
    return this;
  }

  /**
   * Set this to allow the issuer will expose a CRL endpoint in the Gateway
   * @return createPrivateCrl
   */
  @javax.annotation.Nullable
  public Boolean getCreatePrivateCrl() {
    return createPrivateCrl;
  }

  public void setCreatePrivateCrl(@javax.annotation.Nullable Boolean createPrivateCrl) {
    this.createPrivateCrl = createPrivateCrl;
  }


  public CreatePKICertIssuer createPublicCrl(@javax.annotation.Nullable Boolean createPublicCrl) {
    this.createPublicCrl = createPublicCrl;
    return this;
  }

  /**
   * Set this to allow the cert issuer will expose a public CRL endpoint
   * @return createPublicCrl
   */
  @javax.annotation.Nullable
  public Boolean getCreatePublicCrl() {
    return createPublicCrl;
  }

  public void setCreatePublicCrl(@javax.annotation.Nullable Boolean createPublicCrl) {
    this.createPublicCrl = createPublicCrl;
  }


  public CreatePKICertIssuer criticalKeyUsage(@javax.annotation.Nullable String criticalKeyUsage) {
    this.criticalKeyUsage = criticalKeyUsage;
    return this;
  }

  /**
   * Mark key usage as critical [true/false]
   * @return criticalKeyUsage
   */
  @javax.annotation.Nullable
  public String getCriticalKeyUsage() {
    return criticalKeyUsage;
  }

  public void setCriticalKeyUsage(@javax.annotation.Nullable String criticalKeyUsage) {
    this.criticalKeyUsage = criticalKeyUsage;
  }


  public CreatePKICertIssuer deleteProtection(@javax.annotation.Nullable String deleteProtection) {
    this.deleteProtection = deleteProtection;
    return this;
  }

  /**
   * Protection from accidental deletion of this object [true/false]
   * @return deleteProtection
   */
  @javax.annotation.Nullable
  public String getDeleteProtection() {
    return deleteProtection;
  }

  public void setDeleteProtection(@javax.annotation.Nullable String deleteProtection) {
    this.deleteProtection = deleteProtection;
  }


  public CreatePKICertIssuer description(@javax.annotation.Nullable String description) {
    this.description = description;
    return this;
  }

  /**
   * Description of the object
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = description;
  }


  public CreatePKICertIssuer destinationPath(@javax.annotation.Nullable String destinationPath) {
    this.destinationPath = destinationPath;
    return this;
  }

  /**
   * A path in which to save generated certificates
   * @return destinationPath
   */
  @javax.annotation.Nullable
  public String getDestinationPath() {
    return destinationPath;
  }

  public void setDestinationPath(@javax.annotation.Nullable String destinationPath) {
    this.destinationPath = destinationPath;
  }


  public CreatePKICertIssuer disableWildcards(@javax.annotation.Nullable Boolean disableWildcards) {
    this.disableWildcards = disableWildcards;
    return this;
  }

  /**
   * If set, generation of wildcard certificates will be disabled.
   * @return disableWildcards
   */
  @javax.annotation.Nullable
  public Boolean getDisableWildcards() {
    return disableWildcards;
  }

  public void setDisableWildcards(@javax.annotation.Nullable Boolean disableWildcards) {
    this.disableWildcards = disableWildcards;
  }


  public CreatePKICertIssuer enableAcme(@javax.annotation.Nullable Boolean enableAcme) {
    this.enableAcme = enableAcme;
    return this;
  }

  /**
   * If set, the cert issuer will support the acme protocol
   * @return enableAcme
   */
  @javax.annotation.Nullable
  public Boolean getEnableAcme() {
    return enableAcme;
  }

  public void setEnableAcme(@javax.annotation.Nullable Boolean enableAcme) {
    this.enableAcme = enableAcme;
  }


  public CreatePKICertIssuer expirationEventIn(@javax.annotation.Nullable List<String> expirationEventIn) {
    this.expirationEventIn = expirationEventIn;
    return this;
  }

  public CreatePKICertIssuer addExpirationEventInItem(String expirationEventInItem) {
    if (this.expirationEventIn == null) {
      this.expirationEventIn = new ArrayList<>();
    }
    this.expirationEventIn.add(expirationEventInItem);
    return this;
  }

  /**
   * How many days before the expiration of the certificate would you like to be notified.
   * @return expirationEventIn
   */
  @javax.annotation.Nullable
  public List<String> getExpirationEventIn() {
    return expirationEventIn;
  }

  public void setExpirationEventIn(@javax.annotation.Nullable List<String> expirationEventIn) {
    this.expirationEventIn = expirationEventIn;
  }


  public CreatePKICertIssuer gwClusterUrl(@javax.annotation.Nullable String gwClusterUrl) {
    this.gwClusterUrl = gwClusterUrl;
    return this;
  }

  /**
   * The GW cluster URL to issue the certificate from. Required in Public CA mode, to allow CRLs on private CA, or to enable ACME
   * @return gwClusterUrl
   */
  @javax.annotation.Nullable
  public String getGwClusterUrl() {
    return gwClusterUrl;
  }

  public void setGwClusterUrl(@javax.annotation.Nullable String gwClusterUrl) {
    this.gwClusterUrl = gwClusterUrl;
  }


  public CreatePKICertIssuer isCa(@javax.annotation.Nullable Boolean isCa) {
    this.isCa = isCa;
    return this;
  }

  /**
   * If set, the basic constraints extension will be added to certificate
   * @return isCa
   */
  @javax.annotation.Nullable
  public Boolean getIsCa() {
    return isCa;
  }

  public void setIsCa(@javax.annotation.Nullable Boolean isCa) {
    this.isCa = isCa;
  }


  public CreatePKICertIssuer json(@javax.annotation.Nullable Boolean json) {
    this.json = json;
    return this;
  }

  /**
   * Set output format to JSON
   * @return json
   */
  @javax.annotation.Nullable
  public Boolean getJson() {
    return json;
  }

  public void setJson(@javax.annotation.Nullable Boolean json) {
    this.json = json;
  }


  public CreatePKICertIssuer keyUsage(@javax.annotation.Nullable String keyUsage) {
    this.keyUsage = keyUsage;
    return this;
  }

  /**
   * key-usage
   * @return keyUsage
   */
  @javax.annotation.Nullable
  public String getKeyUsage() {
    return keyUsage;
  }

  public void setKeyUsage(@javax.annotation.Nullable String keyUsage) {
    this.keyUsage = keyUsage;
  }


  public CreatePKICertIssuer locality(@javax.annotation.Nullable String locality) {
    this.locality = locality;
    return this;
  }

  /**
   * A comma-separated list of localities that will be set in the issued certificate
   * @return locality
   */
  @javax.annotation.Nullable
  public String getLocality() {
    return locality;
  }

  public void setLocality(@javax.annotation.Nullable String locality) {
    this.locality = locality;
  }


  public CreatePKICertIssuer maxPathLen(@javax.annotation.Nullable Long maxPathLen) {
    this.maxPathLen = maxPathLen;
    return this;
  }

  /**
   * The maximum path length for the generated certificate. -1, means unlimited
   * @return maxPathLen
   */
  @javax.annotation.Nullable
  public Long getMaxPathLen() {
    return maxPathLen;
  }

  public void setMaxPathLen(@javax.annotation.Nullable Long maxPathLen) {
    this.maxPathLen = maxPathLen;
  }


  public CreatePKICertIssuer metadata(@javax.annotation.Nullable String metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Deprecated - use description
   * @return metadata
   */
  @javax.annotation.Nullable
  public String getMetadata() {
    return metadata;
  }

  public void setMetadata(@javax.annotation.Nullable String metadata) {
    this.metadata = metadata;
  }


  public CreatePKICertIssuer name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * PKI certificate issuer name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public CreatePKICertIssuer notEnforceHostnames(@javax.annotation.Nullable Boolean notEnforceHostnames) {
    this.notEnforceHostnames = notEnforceHostnames;
    return this;
  }

  /**
   * If set, any names are allowed for CN and SANs in the certificate and not only a valid host name
   * @return notEnforceHostnames
   */
  @javax.annotation.Nullable
  public Boolean getNotEnforceHostnames() {
    return notEnforceHostnames;
  }

  public void setNotEnforceHostnames(@javax.annotation.Nullable Boolean notEnforceHostnames) {
    this.notEnforceHostnames = notEnforceHostnames;
  }


  public CreatePKICertIssuer notRequireCn(@javax.annotation.Nullable Boolean notRequireCn) {
    this.notRequireCn = notRequireCn;
    return this;
  }

  /**
   * If set, clients can request certificates without a CN
   * @return notRequireCn
   */
  @javax.annotation.Nullable
  public Boolean getNotRequireCn() {
    return notRequireCn;
  }

  public void setNotRequireCn(@javax.annotation.Nullable Boolean notRequireCn) {
    this.notRequireCn = notRequireCn;
  }


  public CreatePKICertIssuer organizationalUnits(@javax.annotation.Nullable String organizationalUnits) {
    this.organizationalUnits = organizationalUnits;
    return this;
  }

  /**
   * A comma-separated list of organizational units (OU) that will be set in the issued certificate
   * @return organizationalUnits
   */
  @javax.annotation.Nullable
  public String getOrganizationalUnits() {
    return organizationalUnits;
  }

  public void setOrganizationalUnits(@javax.annotation.Nullable String organizationalUnits) {
    this.organizationalUnits = organizationalUnits;
  }


  public CreatePKICertIssuer organizations(@javax.annotation.Nullable String organizations) {
    this.organizations = organizations;
    return this;
  }

  /**
   * A comma-separated list of organizations (O) that will be set in the issued certificate
   * @return organizations
   */
  @javax.annotation.Nullable
  public String getOrganizations() {
    return organizations;
  }

  public void setOrganizations(@javax.annotation.Nullable String organizations) {
    this.organizations = organizations;
  }


  public CreatePKICertIssuer postalCode(@javax.annotation.Nullable String postalCode) {
    this.postalCode = postalCode;
    return this;
  }

  /**
   * A comma-separated list of postal codes that will be set in the issued certificate
   * @return postalCode
   */
  @javax.annotation.Nullable
  public String getPostalCode() {
    return postalCode;
  }

  public void setPostalCode(@javax.annotation.Nullable String postalCode) {
    this.postalCode = postalCode;
  }


  public CreatePKICertIssuer protectCertificates(@javax.annotation.Nullable Boolean protectCertificates) {
    this.protectCertificates = protectCertificates;
    return this;
  }

  /**
   * Whether to protect generated certificates from deletion
   * @return protectCertificates
   */
  @javax.annotation.Nullable
  public Boolean getProtectCertificates() {
    return protectCertificates;
  }

  public void setProtectCertificates(@javax.annotation.Nullable Boolean protectCertificates) {
    this.protectCertificates = protectCertificates;
  }


  public CreatePKICertIssuer province(@javax.annotation.Nullable String province) {
    this.province = province;
    return this;
  }

  /**
   * A comma-separated list of provinces that will be set in the issued certificate
   * @return province
   */
  @javax.annotation.Nullable
  public String getProvince() {
    return province;
  }

  public void setProvince(@javax.annotation.Nullable String province) {
    this.province = province;
  }


  public CreatePKICertIssuer scheduledRenew(@javax.annotation.Nullable Long scheduledRenew) {
    this.scheduledRenew = scheduledRenew;
    return this;
  }

  /**
   * Number of days before expiration to renew certificates
   * @return scheduledRenew
   */
  @javax.annotation.Nullable
  public Long getScheduledRenew() {
    return scheduledRenew;
  }

  public void setScheduledRenew(@javax.annotation.Nullable Long scheduledRenew) {
    this.scheduledRenew = scheduledRenew;
  }


  public CreatePKICertIssuer serverFlag(@javax.annotation.Nullable Boolean serverFlag) {
    this.serverFlag = serverFlag;
    return this;
  }

  /**
   * If set, certificates will be flagged for server auth use
   * @return serverFlag
   */
  @javax.annotation.Nullable
  public Boolean getServerFlag() {
    return serverFlag;
  }

  public void setServerFlag(@javax.annotation.Nullable Boolean serverFlag) {
    this.serverFlag = serverFlag;
  }


  public CreatePKICertIssuer signerKeyName(@javax.annotation.Nullable String signerKeyName) {
    this.signerKeyName = signerKeyName;
    return this;
  }

  /**
   * A key to sign the certificate with, required in Private CA mode
   * @return signerKeyName
   */
  @javax.annotation.Nullable
  public String getSignerKeyName() {
    return signerKeyName;
  }

  public void setSignerKeyName(@javax.annotation.Nullable String signerKeyName) {
    this.signerKeyName = signerKeyName;
  }


  public CreatePKICertIssuer streetAddress(@javax.annotation.Nullable String streetAddress) {
    this.streetAddress = streetAddress;
    return this;
  }

  /**
   * A comma-separated list of street addresses that will be set in the issued certificate
   * @return streetAddress
   */
  @javax.annotation.Nullable
  public String getStreetAddress() {
    return streetAddress;
  }

  public void setStreetAddress(@javax.annotation.Nullable String streetAddress) {
    this.streetAddress = streetAddress;
  }


  public CreatePKICertIssuer tag(@javax.annotation.Nullable List<String> tag) {
    this.tag = tag;
    return this;
  }

  public CreatePKICertIssuer addTagItem(String tagItem) {
    if (this.tag == null) {
      this.tag = new ArrayList<>();
    }
    this.tag.add(tagItem);
    return this;
  }

  /**
   * List of the tags attached to this key
   * @return tag
   */
  @javax.annotation.Nullable
  public List<String> getTag() {
    return tag;
  }

  public void setTag(@javax.annotation.Nullable List<String> tag) {
    this.tag = tag;
  }


  public CreatePKICertIssuer token(@javax.annotation.Nullable String token) {
    this.token = token;
    return this;
  }

  /**
   * Authentication token (see &#x60;/auth&#x60; and &#x60;/configure&#x60;)
   * @return token
   */
  @javax.annotation.Nullable
  public String getToken() {
    return token;
  }

  public void setToken(@javax.annotation.Nullable String token) {
    this.token = token;
  }


  public CreatePKICertIssuer ttl(@javax.annotation.Nonnull String ttl) {
    this.ttl = ttl;
    return this;
  }

  /**
   * The maximum requested Time To Live for issued certificates, in seconds. In case of Public CA, this is based on the CA target&#39;s supported maximum TTLs
   * @return ttl
   */
  @javax.annotation.Nonnull
  public String getTtl() {
    return ttl;
  }

  public void setTtl(@javax.annotation.Nonnull String ttl) {
    this.ttl = ttl;
  }


  public CreatePKICertIssuer uidToken(@javax.annotation.Nullable String uidToken) {
    this.uidToken = uidToken;
    return this;
  }

  /**
   * The universal identity token, Required only for universal_identity authentication
   * @return uidToken
   */
  @javax.annotation.Nullable
  public String getUidToken() {
    return uidToken;
  }

  public void setUidToken(@javax.annotation.Nullable String uidToken) {
    this.uidToken = uidToken;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreatePKICertIssuer createPKICertIssuer = (CreatePKICertIssuer) o;
    return Objects.equals(this.allowAnyName, createPKICertIssuer.allowAnyName) &&
        Objects.equals(this.allowCopyExtFromCsr, createPKICertIssuer.allowCopyExtFromCsr) &&
        Objects.equals(this.allowSubdomains, createPKICertIssuer.allowSubdomains) &&
        Objects.equals(this.allowedDomains, createPKICertIssuer.allowedDomains) &&
        Objects.equals(this.allowedExtraExtensions, createPKICertIssuer.allowedExtraExtensions) &&
        Objects.equals(this.allowedIpSans, createPKICertIssuer.allowedIpSans) &&
        Objects.equals(this.allowedUriSans, createPKICertIssuer.allowedUriSans) &&
        Objects.equals(this.autoRenew, createPKICertIssuer.autoRenew) &&
        Objects.equals(this.caTarget, createPKICertIssuer.caTarget) &&
        Objects.equals(this.clientFlag, createPKICertIssuer.clientFlag) &&
        Objects.equals(this.codeSigningFlag, createPKICertIssuer.codeSigningFlag) &&
        Objects.equals(this.country, createPKICertIssuer.country) &&
        Objects.equals(this.createPrivateCrl, createPKICertIssuer.createPrivateCrl) &&
        Objects.equals(this.createPublicCrl, createPKICertIssuer.createPublicCrl) &&
        Objects.equals(this.criticalKeyUsage, createPKICertIssuer.criticalKeyUsage) &&
        Objects.equals(this.deleteProtection, createPKICertIssuer.deleteProtection) &&
        Objects.equals(this.description, createPKICertIssuer.description) &&
        Objects.equals(this.destinationPath, createPKICertIssuer.destinationPath) &&
        Objects.equals(this.disableWildcards, createPKICertIssuer.disableWildcards) &&
        Objects.equals(this.enableAcme, createPKICertIssuer.enableAcme) &&
        Objects.equals(this.expirationEventIn, createPKICertIssuer.expirationEventIn) &&
        Objects.equals(this.gwClusterUrl, createPKICertIssuer.gwClusterUrl) &&
        Objects.equals(this.isCa, createPKICertIssuer.isCa) &&
        Objects.equals(this.json, createPKICertIssuer.json) &&
        Objects.equals(this.keyUsage, createPKICertIssuer.keyUsage) &&
        Objects.equals(this.locality, createPKICertIssuer.locality) &&
        Objects.equals(this.maxPathLen, createPKICertIssuer.maxPathLen) &&
        Objects.equals(this.metadata, createPKICertIssuer.metadata) &&
        Objects.equals(this.name, createPKICertIssuer.name) &&
        Objects.equals(this.notEnforceHostnames, createPKICertIssuer.notEnforceHostnames) &&
        Objects.equals(this.notRequireCn, createPKICertIssuer.notRequireCn) &&
        Objects.equals(this.organizationalUnits, createPKICertIssuer.organizationalUnits) &&
        Objects.equals(this.organizations, createPKICertIssuer.organizations) &&
        Objects.equals(this.postalCode, createPKICertIssuer.postalCode) &&
        Objects.equals(this.protectCertificates, createPKICertIssuer.protectCertificates) &&
        Objects.equals(this.province, createPKICertIssuer.province) &&
        Objects.equals(this.scheduledRenew, createPKICertIssuer.scheduledRenew) &&
        Objects.equals(this.serverFlag, createPKICertIssuer.serverFlag) &&
        Objects.equals(this.signerKeyName, createPKICertIssuer.signerKeyName) &&
        Objects.equals(this.streetAddress, createPKICertIssuer.streetAddress) &&
        Objects.equals(this.tag, createPKICertIssuer.tag) &&
        Objects.equals(this.token, createPKICertIssuer.token) &&
        Objects.equals(this.ttl, createPKICertIssuer.ttl) &&
        Objects.equals(this.uidToken, createPKICertIssuer.uidToken);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowAnyName, allowCopyExtFromCsr, allowSubdomains, allowedDomains, allowedExtraExtensions, allowedIpSans, allowedUriSans, autoRenew, caTarget, clientFlag, codeSigningFlag, country, createPrivateCrl, createPublicCrl, criticalKeyUsage, deleteProtection, description, destinationPath, disableWildcards, enableAcme, expirationEventIn, gwClusterUrl, isCa, json, keyUsage, locality, maxPathLen, metadata, name, notEnforceHostnames, notRequireCn, organizationalUnits, organizations, postalCode, protectCertificates, province, scheduledRenew, serverFlag, signerKeyName, streetAddress, tag, token, ttl, uidToken);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreatePKICertIssuer {\n");
    sb.append("    allowAnyName: ").append(toIndentedString(allowAnyName)).append("\n");
    sb.append("    allowCopyExtFromCsr: ").append(toIndentedString(allowCopyExtFromCsr)).append("\n");
    sb.append("    allowSubdomains: ").append(toIndentedString(allowSubdomains)).append("\n");
    sb.append("    allowedDomains: ").append(toIndentedString(allowedDomains)).append("\n");
    sb.append("    allowedExtraExtensions: ").append(toIndentedString(allowedExtraExtensions)).append("\n");
    sb.append("    allowedIpSans: ").append(toIndentedString(allowedIpSans)).append("\n");
    sb.append("    allowedUriSans: ").append(toIndentedString(allowedUriSans)).append("\n");
    sb.append("    autoRenew: ").append(toIndentedString(autoRenew)).append("\n");
    sb.append("    caTarget: ").append(toIndentedString(caTarget)).append("\n");
    sb.append("    clientFlag: ").append(toIndentedString(clientFlag)).append("\n");
    sb.append("    codeSigningFlag: ").append(toIndentedString(codeSigningFlag)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    createPrivateCrl: ").append(toIndentedString(createPrivateCrl)).append("\n");
    sb.append("    createPublicCrl: ").append(toIndentedString(createPublicCrl)).append("\n");
    sb.append("    criticalKeyUsage: ").append(toIndentedString(criticalKeyUsage)).append("\n");
    sb.append("    deleteProtection: ").append(toIndentedString(deleteProtection)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    destinationPath: ").append(toIndentedString(destinationPath)).append("\n");
    sb.append("    disableWildcards: ").append(toIndentedString(disableWildcards)).append("\n");
    sb.append("    enableAcme: ").append(toIndentedString(enableAcme)).append("\n");
    sb.append("    expirationEventIn: ").append(toIndentedString(expirationEventIn)).append("\n");
    sb.append("    gwClusterUrl: ").append(toIndentedString(gwClusterUrl)).append("\n");
    sb.append("    isCa: ").append(toIndentedString(isCa)).append("\n");
    sb.append("    json: ").append(toIndentedString(json)).append("\n");
    sb.append("    keyUsage: ").append(toIndentedString(keyUsage)).append("\n");
    sb.append("    locality: ").append(toIndentedString(locality)).append("\n");
    sb.append("    maxPathLen: ").append(toIndentedString(maxPathLen)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notEnforceHostnames: ").append(toIndentedString(notEnforceHostnames)).append("\n");
    sb.append("    notRequireCn: ").append(toIndentedString(notRequireCn)).append("\n");
    sb.append("    organizationalUnits: ").append(toIndentedString(organizationalUnits)).append("\n");
    sb.append("    organizations: ").append(toIndentedString(organizations)).append("\n");
    sb.append("    postalCode: ").append(toIndentedString(postalCode)).append("\n");
    sb.append("    protectCertificates: ").append(toIndentedString(protectCertificates)).append("\n");
    sb.append("    province: ").append(toIndentedString(province)).append("\n");
    sb.append("    scheduledRenew: ").append(toIndentedString(scheduledRenew)).append("\n");
    sb.append("    serverFlag: ").append(toIndentedString(serverFlag)).append("\n");
    sb.append("    signerKeyName: ").append(toIndentedString(signerKeyName)).append("\n");
    sb.append("    streetAddress: ").append(toIndentedString(streetAddress)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("    uidToken: ").append(toIndentedString(uidToken)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allow-any-name");
    openapiFields.add("allow-copy-ext-from-csr");
    openapiFields.add("allow-subdomains");
    openapiFields.add("allowed-domains");
    openapiFields.add("allowed-extra-extensions");
    openapiFields.add("allowed-ip-sans");
    openapiFields.add("allowed-uri-sans");
    openapiFields.add("auto-renew");
    openapiFields.add("ca-target");
    openapiFields.add("client-flag");
    openapiFields.add("code-signing-flag");
    openapiFields.add("country");
    openapiFields.add("create-private-crl");
    openapiFields.add("create-public-crl");
    openapiFields.add("critical-key-usage");
    openapiFields.add("delete_protection");
    openapiFields.add("description");
    openapiFields.add("destination-path");
    openapiFields.add("disable-wildcards");
    openapiFields.add("enable-acme");
    openapiFields.add("expiration-event-in");
    openapiFields.add("gw-cluster-url");
    openapiFields.add("is-ca");
    openapiFields.add("json");
    openapiFields.add("key-usage");
    openapiFields.add("locality");
    openapiFields.add("max-path-len");
    openapiFields.add("metadata");
    openapiFields.add("name");
    openapiFields.add("not-enforce-hostnames");
    openapiFields.add("not-require-cn");
    openapiFields.add("organizational-units");
    openapiFields.add("organizations");
    openapiFields.add("postal-code");
    openapiFields.add("protect-certificates");
    openapiFields.add("province");
    openapiFields.add("scheduled-renew");
    openapiFields.add("server-flag");
    openapiFields.add("signer-key-name");
    openapiFields.add("street-address");
    openapiFields.add("tag");
    openapiFields.add("token");
    openapiFields.add("ttl");
    openapiFields.add("uid-token");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("ttl");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreatePKICertIssuer
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreatePKICertIssuer.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreatePKICertIssuer is not found in the empty JSON string", CreatePKICertIssuer.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreatePKICertIssuer.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreatePKICertIssuer` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreatePKICertIssuer.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("allowed-domains") != null && !jsonObj.get("allowed-domains").isJsonNull()) && !jsonObj.get("allowed-domains").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowed-domains` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allowed-domains").toString()));
      }
      if ((jsonObj.get("allowed-extra-extensions") != null && !jsonObj.get("allowed-extra-extensions").isJsonNull()) && !jsonObj.get("allowed-extra-extensions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowed-extra-extensions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allowed-extra-extensions").toString()));
      }
      if ((jsonObj.get("allowed-ip-sans") != null && !jsonObj.get("allowed-ip-sans").isJsonNull()) && !jsonObj.get("allowed-ip-sans").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowed-ip-sans` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allowed-ip-sans").toString()));
      }
      if ((jsonObj.get("allowed-uri-sans") != null && !jsonObj.get("allowed-uri-sans").isJsonNull()) && !jsonObj.get("allowed-uri-sans").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowed-uri-sans` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allowed-uri-sans").toString()));
      }
      if ((jsonObj.get("ca-target") != null && !jsonObj.get("ca-target").isJsonNull()) && !jsonObj.get("ca-target").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ca-target` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ca-target").toString()));
      }
      if ((jsonObj.get("country") != null && !jsonObj.get("country").isJsonNull()) && !jsonObj.get("country").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `country` to be a primitive type in the JSON string but got `%s`", jsonObj.get("country").toString()));
      }
      if ((jsonObj.get("critical-key-usage") != null && !jsonObj.get("critical-key-usage").isJsonNull()) && !jsonObj.get("critical-key-usage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `critical-key-usage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("critical-key-usage").toString()));
      }
      if ((jsonObj.get("delete_protection") != null && !jsonObj.get("delete_protection").isJsonNull()) && !jsonObj.get("delete_protection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delete_protection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delete_protection").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("destination-path") != null && !jsonObj.get("destination-path").isJsonNull()) && !jsonObj.get("destination-path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destination-path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destination-path").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("expiration-event-in") != null && !jsonObj.get("expiration-event-in").isJsonNull() && !jsonObj.get("expiration-event-in").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `expiration-event-in` to be an array in the JSON string but got `%s`", jsonObj.get("expiration-event-in").toString()));
      }
      if ((jsonObj.get("gw-cluster-url") != null && !jsonObj.get("gw-cluster-url").isJsonNull()) && !jsonObj.get("gw-cluster-url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gw-cluster-url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gw-cluster-url").toString()));
      }
      if ((jsonObj.get("key-usage") != null && !jsonObj.get("key-usage").isJsonNull()) && !jsonObj.get("key-usage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key-usage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key-usage").toString()));
      }
      if ((jsonObj.get("locality") != null && !jsonObj.get("locality").isJsonNull()) && !jsonObj.get("locality").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locality` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locality").toString()));
      }
      if ((jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) && !jsonObj.get("metadata").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metadata` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metadata").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("organizational-units") != null && !jsonObj.get("organizational-units").isJsonNull()) && !jsonObj.get("organizational-units").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `organizational-units` to be a primitive type in the JSON string but got `%s`", jsonObj.get("organizational-units").toString()));
      }
      if ((jsonObj.get("organizations") != null && !jsonObj.get("organizations").isJsonNull()) && !jsonObj.get("organizations").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `organizations` to be a primitive type in the JSON string but got `%s`", jsonObj.get("organizations").toString()));
      }
      if ((jsonObj.get("postal-code") != null && !jsonObj.get("postal-code").isJsonNull()) && !jsonObj.get("postal-code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postal-code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postal-code").toString()));
      }
      if ((jsonObj.get("province") != null && !jsonObj.get("province").isJsonNull()) && !jsonObj.get("province").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `province` to be a primitive type in the JSON string but got `%s`", jsonObj.get("province").toString()));
      }
      if ((jsonObj.get("signer-key-name") != null && !jsonObj.get("signer-key-name").isJsonNull()) && !jsonObj.get("signer-key-name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `signer-key-name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("signer-key-name").toString()));
      }
      if ((jsonObj.get("street-address") != null && !jsonObj.get("street-address").isJsonNull()) && !jsonObj.get("street-address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `street-address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("street-address").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tag") != null && !jsonObj.get("tag").isJsonNull() && !jsonObj.get("tag").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tag` to be an array in the JSON string but got `%s`", jsonObj.get("tag").toString()));
      }
      if ((jsonObj.get("token") != null && !jsonObj.get("token").isJsonNull()) && !jsonObj.get("token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token").toString()));
      }
      if (!jsonObj.get("ttl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ttl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ttl").toString()));
      }
      if ((jsonObj.get("uid-token") != null && !jsonObj.get("uid-token").isJsonNull()) && !jsonObj.get("uid-token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid-token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid-token").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreatePKICertIssuer.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreatePKICertIssuer' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreatePKICertIssuer> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreatePKICertIssuer.class));

       return (TypeAdapter<T>) new TypeAdapter<CreatePKICertIssuer>() {
           @Override
           public void write(JsonWriter out, CreatePKICertIssuer value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreatePKICertIssuer read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreatePKICertIssuer given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreatePKICertIssuer
   * @throws IOException if the JSON string is invalid with respect to CreatePKICertIssuer
   */
  public static CreatePKICertIssuer fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreatePKICertIssuer.class);
  }

  /**
   * Convert an instance of CreatePKICertIssuer to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

