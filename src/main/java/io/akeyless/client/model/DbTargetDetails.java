/*
 * Akeyless API
 * The purpose of this application is to provide access to Akeyless API.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@akeyless.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.akeyless.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * DbTargetDetails
 */
@ApiModel(description = "DbTargetDetails")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DbTargetDetails {
  public static final String SERIALIZED_NAME_DB_HOST_NAME = "db_host_name";
  @SerializedName(SERIALIZED_NAME_DB_HOST_NAME)
  private String dbHostName;

  public static final String SERIALIZED_NAME_DB_NAME = "db_name";
  @SerializedName(SERIALIZED_NAME_DB_NAME)
  private String dbName;

  public static final String SERIALIZED_NAME_DB_PORT = "db_port";
  @SerializedName(SERIALIZED_NAME_DB_PORT)
  private String dbPort;

  public static final String SERIALIZED_NAME_DB_PRIVATE_KEY = "db_private_key";
  @SerializedName(SERIALIZED_NAME_DB_PRIVATE_KEY)
  private String dbPrivateKey;

  public static final String SERIALIZED_NAME_DB_PRIVATE_KEY_PASSPHRASE = "db_private_key_passphrase";
  @SerializedName(SERIALIZED_NAME_DB_PRIVATE_KEY_PASSPHRASE)
  private String dbPrivateKeyPassphrase;

  public static final String SERIALIZED_NAME_DB_PWD = "db_pwd";
  @SerializedName(SERIALIZED_NAME_DB_PWD)
  private String dbPwd;

  public static final String SERIALIZED_NAME_DB_SERVER_CERTIFICATES = "db_server_certificates";
  @SerializedName(SERIALIZED_NAME_DB_SERVER_CERTIFICATES)
  private String dbServerCertificates;

  public static final String SERIALIZED_NAME_DB_SERVER_NAME = "db_server_name";
  @SerializedName(SERIALIZED_NAME_DB_SERVER_NAME)
  private String dbServerName;

  public static final String SERIALIZED_NAME_DB_USER_NAME = "db_user_name";
  @SerializedName(SERIALIZED_NAME_DB_USER_NAME)
  private String dbUserName;

  public static final String SERIALIZED_NAME_SF_ACCOUNT = "sf_account";
  @SerializedName(SERIALIZED_NAME_SF_ACCOUNT)
  private String sfAccount;

  public static final String SERIALIZED_NAME_SSL_CONNECTION_CERTIFICATE = "ssl_connection_certificate";
  @SerializedName(SERIALIZED_NAME_SSL_CONNECTION_CERTIFICATE)
  private String sslConnectionCertificate;

  public static final String SERIALIZED_NAME_SSL_CONNECTION_MODE = "ssl_connection_mode";
  @SerializedName(SERIALIZED_NAME_SSL_CONNECTION_MODE)
  private Boolean sslConnectionMode;

  public DbTargetDetails() { 
  }

  public DbTargetDetails dbHostName(String dbHostName) {
    
    this.dbHostName = dbHostName;
    return this;
  }

   /**
   * Get dbHostName
   * @return dbHostName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDbHostName() {
    return dbHostName;
  }


  public void setDbHostName(String dbHostName) {
    this.dbHostName = dbHostName;
  }


  public DbTargetDetails dbName(String dbName) {
    
    this.dbName = dbName;
    return this;
  }

   /**
   * Get dbName
   * @return dbName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDbName() {
    return dbName;
  }


  public void setDbName(String dbName) {
    this.dbName = dbName;
  }


  public DbTargetDetails dbPort(String dbPort) {
    
    this.dbPort = dbPort;
    return this;
  }

   /**
   * Get dbPort
   * @return dbPort
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDbPort() {
    return dbPort;
  }


  public void setDbPort(String dbPort) {
    this.dbPort = dbPort;
  }


  public DbTargetDetails dbPrivateKey(String dbPrivateKey) {
    
    this.dbPrivateKey = dbPrivateKey;
    return this;
  }

   /**
   * (Optional) Private Key in PEM format
   * @return dbPrivateKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "(Optional) Private Key in PEM format")

  public String getDbPrivateKey() {
    return dbPrivateKey;
  }


  public void setDbPrivateKey(String dbPrivateKey) {
    this.dbPrivateKey = dbPrivateKey;
  }


  public DbTargetDetails dbPrivateKeyPassphrase(String dbPrivateKeyPassphrase) {
    
    this.dbPrivateKeyPassphrase = dbPrivateKeyPassphrase;
    return this;
  }

   /**
   * Get dbPrivateKeyPassphrase
   * @return dbPrivateKeyPassphrase
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDbPrivateKeyPassphrase() {
    return dbPrivateKeyPassphrase;
  }


  public void setDbPrivateKeyPassphrase(String dbPrivateKeyPassphrase) {
    this.dbPrivateKeyPassphrase = dbPrivateKeyPassphrase;
  }


  public DbTargetDetails dbPwd(String dbPwd) {
    
    this.dbPwd = dbPwd;
    return this;
  }

   /**
   * Get dbPwd
   * @return dbPwd
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDbPwd() {
    return dbPwd;
  }


  public void setDbPwd(String dbPwd) {
    this.dbPwd = dbPwd;
  }


  public DbTargetDetails dbServerCertificates(String dbServerCertificates) {
    
    this.dbServerCertificates = dbServerCertificates;
    return this;
  }

   /**
   * (Optional) DBServerCertificates defines the set of root certificate authorities that clients use when verifying server certificates. If DBServerCertificates is empty, TLS uses the host&#39;s root CA set.
   * @return dbServerCertificates
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "(Optional) DBServerCertificates defines the set of root certificate authorities that clients use when verifying server certificates. If DBServerCertificates is empty, TLS uses the host's root CA set.")

  public String getDbServerCertificates() {
    return dbServerCertificates;
  }


  public void setDbServerCertificates(String dbServerCertificates) {
    this.dbServerCertificates = dbServerCertificates;
  }


  public DbTargetDetails dbServerName(String dbServerName) {
    
    this.dbServerName = dbServerName;
    return this;
  }

   /**
   * (Optional) ServerName is used to verify the hostname on the returned certificates unless InsecureSkipVerify is given. It is also included in the client&#39;s handshake to support virtual hosting unless it is an IP address.
   * @return dbServerName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "(Optional) ServerName is used to verify the hostname on the returned certificates unless InsecureSkipVerify is given. It is also included in the client's handshake to support virtual hosting unless it is an IP address.")

  public String getDbServerName() {
    return dbServerName;
  }


  public void setDbServerName(String dbServerName) {
    this.dbServerName = dbServerName;
  }


  public DbTargetDetails dbUserName(String dbUserName) {
    
    this.dbUserName = dbUserName;
    return this;
  }

   /**
   * Get dbUserName
   * @return dbUserName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getDbUserName() {
    return dbUserName;
  }


  public void setDbUserName(String dbUserName) {
    this.dbUserName = dbUserName;
  }


  public DbTargetDetails sfAccount(String sfAccount) {
    
    this.sfAccount = sfAccount;
    return this;
  }

   /**
   * Get sfAccount
   * @return sfAccount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getSfAccount() {
    return sfAccount;
  }


  public void setSfAccount(String sfAccount) {
    this.sfAccount = sfAccount;
  }


  public DbTargetDetails sslConnectionCertificate(String sslConnectionCertificate) {
    
    this.sslConnectionCertificate = sslConnectionCertificate;
    return this;
  }

   /**
   * (Optional) SSLConnectionCertificate defines the certificate for SSL connection. Must be base64 certificate loaded by UI using file loader field
   * @return sslConnectionCertificate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "(Optional) SSLConnectionCertificate defines the certificate for SSL connection. Must be base64 certificate loaded by UI using file loader field")

  public String getSslConnectionCertificate() {
    return sslConnectionCertificate;
  }


  public void setSslConnectionCertificate(String sslConnectionCertificate) {
    this.sslConnectionCertificate = sslConnectionCertificate;
  }


  public DbTargetDetails sslConnectionMode(Boolean sslConnectionMode) {
    
    this.sslConnectionMode = sslConnectionMode;
    return this;
  }

   /**
   * (Optional) SSLConnectionMode defines if SSL mode will be used to connect to DB
   * @return sslConnectionMode
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "(Optional) SSLConnectionMode defines if SSL mode will be used to connect to DB")

  public Boolean getSslConnectionMode() {
    return sslConnectionMode;
  }


  public void setSslConnectionMode(Boolean sslConnectionMode) {
    this.sslConnectionMode = sslConnectionMode;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DbTargetDetails dbTargetDetails = (DbTargetDetails) o;
    return Objects.equals(this.dbHostName, dbTargetDetails.dbHostName) &&
        Objects.equals(this.dbName, dbTargetDetails.dbName) &&
        Objects.equals(this.dbPort, dbTargetDetails.dbPort) &&
        Objects.equals(this.dbPrivateKey, dbTargetDetails.dbPrivateKey) &&
        Objects.equals(this.dbPrivateKeyPassphrase, dbTargetDetails.dbPrivateKeyPassphrase) &&
        Objects.equals(this.dbPwd, dbTargetDetails.dbPwd) &&
        Objects.equals(this.dbServerCertificates, dbTargetDetails.dbServerCertificates) &&
        Objects.equals(this.dbServerName, dbTargetDetails.dbServerName) &&
        Objects.equals(this.dbUserName, dbTargetDetails.dbUserName) &&
        Objects.equals(this.sfAccount, dbTargetDetails.sfAccount) &&
        Objects.equals(this.sslConnectionCertificate, dbTargetDetails.sslConnectionCertificate) &&
        Objects.equals(this.sslConnectionMode, dbTargetDetails.sslConnectionMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dbHostName, dbName, dbPort, dbPrivateKey, dbPrivateKeyPassphrase, dbPwd, dbServerCertificates, dbServerName, dbUserName, sfAccount, sslConnectionCertificate, sslConnectionMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DbTargetDetails {\n");
    sb.append("    dbHostName: ").append(toIndentedString(dbHostName)).append("\n");
    sb.append("    dbName: ").append(toIndentedString(dbName)).append("\n");
    sb.append("    dbPort: ").append(toIndentedString(dbPort)).append("\n");
    sb.append("    dbPrivateKey: ").append(toIndentedString(dbPrivateKey)).append("\n");
    sb.append("    dbPrivateKeyPassphrase: ").append(toIndentedString(dbPrivateKeyPassphrase)).append("\n");
    sb.append("    dbPwd: ").append(toIndentedString(dbPwd)).append("\n");
    sb.append("    dbServerCertificates: ").append(toIndentedString(dbServerCertificates)).append("\n");
    sb.append("    dbServerName: ").append(toIndentedString(dbServerName)).append("\n");
    sb.append("    dbUserName: ").append(toIndentedString(dbUserName)).append("\n");
    sb.append("    sfAccount: ").append(toIndentedString(sfAccount)).append("\n");
    sb.append("    sslConnectionCertificate: ").append(toIndentedString(sslConnectionCertificate)).append("\n");
    sb.append("    sslConnectionMode: ").append(toIndentedString(sslConnectionMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

